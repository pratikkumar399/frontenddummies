
### Understanding Promise Retry

A retry function is a utility that automatically retries a failing async operation a specified number of times before giving up. This is essential for handling transient failures like network issues or server errors.

### The Problem

APIs and network requests can fail temporarily due to:
- Network congestion or timeouts
- Server overload (503 errors)
- Rate limiting (429 errors)
- Temporary database issues

Instead of failing immediately, we want to retry the operation a few times with optional delays between attempts.

### Implementation Strategy

1. **Track attempt count**: Keep count of how many retries have been made
2. **Handle rejection**: When the promise rejects, check if we have retries left
3. **Delay between retries**: Optionally wait before retrying
4. **Recursive or iterative**: Can be implemented either way

### Solution 1: Recursive Approach

```javascript
function retry(asyncFn, retries = 3, delay = 0) {
  return new Promise((resolve, reject) => {
    asyncFn()
      .then(resolve)
      .catch((error) => {
        if (retries <= 0) {
          reject(error);
          return;
        }
        
        setTimeout(() => {
          retry(asyncFn, retries - 1, delay)
            .then(resolve)
            .catch(reject);
        }, delay);
      });
  });
}
```

### Solution 2: Async/Await Approach

```javascript
async function retry(asyncFn, retries = 3, delay = 0) {
  for (let i = 0; i <= retries; i++) {
    try {
      return await asyncFn();
    } catch (error) {
      if (i === retries) {
        throw error;
      }
      
      if (delay > 0) {
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  }
}
```

### Key Points

1. **Closure over attempt count**: The retry logic maintains its own counter
2. **Promise chaining**: Each retry creates a new promise chain
3. **Error propagation**: Only throw/reject after all retries are exhausted
4. **Delay handling**: Use `setTimeout` wrapped in a Promise for async delays

### Advanced: Exponential Backoff

In production, you often want exponential backoff where delays increase with each retry:

```javascript
async function retryWithBackoff(asyncFn, retries = 3, baseDelay = 1000) {
  for (let i = 0; i <= retries; i++) {
    try {
      return await asyncFn();
    } catch (error) {
      if (i === retries) {
        throw error;
      }
      
      // Exponential backoff: 1s, 2s, 4s, 8s...
      const delay = baseDelay * Math.pow(2, i);
      // Add jitter to prevent thundering herd
      const jitter = Math.random() * 1000;
      
      await new Promise(resolve => 
        setTimeout(resolve, delay + jitter)
      );
    }
  }
}
```

### Time Complexity
- **O(n)** where n is the number of retries

### Space Complexity
- **O(1)** for iterative approach
- **O(n)** for recursive approach (call stack)

### Common Use Cases

- **API calls**: Retry failed HTTP requests
- **Database connections**: Retry on connection timeout
- **File operations**: Retry on temporary file locks
- **Third-party services**: Handle intermittent failures

### Edge Cases to Consider

1. **Immediate success**: Should work without any retries
2. **All retries fail**: Should reject with the last error
3. **Zero retries**: Should try exactly once
4. **Negative retries**: Handle gracefully (treat as zero)
5. **Async function throws synchronously**: Should still be caught

### Production Considerations

```javascript
async function retry(asyncFn, options = {}) {
  const {
    retries = 3,
    delay = 0,
    backoff = false,
    onRetry = () => {},
    shouldRetry = () => true
  } = options;

  let lastError;
  
  for (let attempt = 0; attempt <= retries; attempt++) {
    try {
      return await asyncFn(attempt);
    } catch (error) {
      lastError = error;
      
      if (attempt === retries || !shouldRetry(error)) {
        throw error;
      }
      
      onRetry(error, attempt);
      
      const waitTime = backoff 
        ? delay * Math.pow(2, attempt) 
        : delay;
        
      if (waitTime > 0) {
        await new Promise(r => setTimeout(r, waitTime));
      }
    }
  }
  
  throw lastError;
}
```

This production version supports:
- **Callbacks**: `onRetry` for logging/metrics
- **Conditional retry**: `shouldRetry` to skip retries for certain errors (e.g., 404s)
- **Optional backoff**: Exponential backoff when needed
- **Attempt tracking**: Pass attempt number to the async function


